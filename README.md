# Компилятор языка Pascal--

__Цель данной работы__  — разработать программную систему, позволяющую "компилировать" и выполнять код на языке Pascal--.
## Формулировка задачи
* Объектом работы является исполняемый объект.
* Код программы состоит из блока названия, опциональных блоков констант и переменных, тела программы, которое может содержать инструкции для работы с числами, операции ввода/вывода, условные конструкции неограниченной вложенности.
* Для кода программы представлены следующие требования:
  - в начале указано название программы после ключевого слова program,
  - ключевые слова 'begin' и 'end' соответственно объявляют начало и конец блока,
  - каждое выражение внутри блока и сам блок (кроме блоков констант и переменных) заканчиваются ';', за исключением тела программы, которое заканчивается '.',
  - имена переменных и констант регистронезависимы,
  - имена переменных и констант не могут начинаться с цифры или иметь названия ключевых слов языка Pascal--,
  - переменная не может быть объявлена одновременного как константа и переменная,
  - переменные и константы принимают тип integer или real,
  - начало блока и конец блока имеют одинаковый отступ в 2 пробела относительно родительского блока,
* Пользователь вводит название файла, в котором содержится код программы, производится разбор текста с выделением блоков и построением иерархии условных конструкций. На следующем этапе производится лексический и синтаксический анализ корректности программы. Компилятор выполняет анализ иерархического списка для создания исполняемого объекта.
## Ключевые моменты работы программы
* Иерархический список, содержащий обработанный текст программы, представляет собой бинарное дерево, в котором правая ветвь содержит начало вложенного блока, а левая - следующий элемент текущего блока.
* Лексическая проверка текста включает в себя проверку на корректность названий переменных, корректность используемых символов.
* Синтаксическая проверка включает корректность использования лексем в контексте.
* Компилятор по иерархическому списку строит тсполняемый объект, содержащий в себе таблицы констант и переменных, дерево выражений.
* Арифметические выражения выполняются при помощи постфиксной формы.

## Основные объекты
* Постфиксная форма:
  * хранит инфиксное и постфиксное представления, набор лексем,
  * позволяет реализовать алгоритм перевода в постфиксное представление и выполнить вычисление арифметического выражения по нему.
* Лексемы языка Pascal--:
  * хранит тип лексемы и её значение.
* Стек:
  * хранит массив данных, размер массива и индекс вершины стека,
  * позволяет изменять вершину стека: добавлять новую, либо удалять старую.
* Список:
  * хранит указатель на начальный узел и размер списка,
  * позволяет вставить элемент в начало.
* Двоичное дерево:
  * хранит указатель на корень дерева,
  * каждый узел имеет не более двух потомков.
* Иерархический список:
  * хранит вложенную структуру блоков и их содержание.
* Неупорядоченная таблица на списке:
  * хранит массив списков и его размер,
  * предоставляет возможность добавления, удаления и поиска записей.
* Исполняемый объект:
  * хранит таблицу констант и таблицу переменных,
  * хранит алгоритм выполнения программы.
* Среда выполнения:
  * хранит исполняемый объект, все коды ошибок и их описание,
  * позволяет выполнить разбор текста, произвести контроль синтаксиса, компилировать код и выполнить программу.

### Алгоритм работы с таблицей на списке:

#### 1. Добавление элемента:
   1. По переданному ключу ищем элемент:
      1. Если элемент с данным именем найден, то алгоритм прекращает свою работу без добавления элемента.
      2. Если элемент с данным именем не найден, то алгоритм продолжает свою работу.
   2. Создаем звено и заполняем его данными.
   3. Добавляем созданное звено в начало списка
#### 2. Удаление элемента:
   1. По переданному ключу ищем элемент, который нужно удалить.
   2. Удаляем элемент из списка, используя обычный алгоритм удаления работы со списками.
#### 3. Поиск элемента:
   1. Запоминаем указатель на первое звено списка.
   2. Пока не дошли до конца списка, сравниваем имя элемента и переданный ключ:
      1. Если они равны, мы нашли нужный элемент. Алгоритм прекращает свою работу.
      2. Если они не равны, переставляем указатель на следующее звено списка. Повторяем пункт 2.
   3. Если дошли до конца списка и не нашли элемент, то возвращаем признак отсутствия элемента. Алгоритм прекращает свою работу.

### Алгоритмы работы с Постфиксной формой для арифметических выражений:

#### 1. Проверка правильности расстановки скобок

1) На вход поступает строка, которая содержит арифметическое выражение.
2) Все символы строки просматриваются слева направо. Символы, не являющиеся скобками, игнорируются.
3) Если текущий символ – открывающаяся скобка, то в стек помещается временное значение true.
4) Если текущий символ – закрывающаяся скобка, то из стека выталкивается временное значение true.
   1) Если стек оказывается пустым, то не нашлось пары для закрывающейся скобки – это ошибка в расстановке скобок. Алгоритм прекращает свою работу.
5) Если все символы строки были просмотрены и стек временных значений не пуст, то не нашлось хотя бы одной пары для открывающейся скобки – это ошибка в расстановке скобок. Алгоритм прекращает свою работу.
6) Если все символы строки были просмотрены и стек временных значений пуст, то нет ошибок в расстановке скобок. Алгоритм прекращает свою работу.

#### 2. Преобразование в постфиксную форму:

1. На вход поступает набор, состоящий из всех элементов арифметического выражения отдельно. 
   Он просматривается слева направо:
   1. Если текущий элемент – лексема, то помещаем её в постфиксное представление.
   2. Если текущий элемент – открывающаяся скобка, то помещаем её в стек.
   3. Если текущий элемент – закрывающаяся скобка, то помещаем все операции до открывающейся скобки с удалением из стека в постфиксную форму (скобку также удаляем).
   4. Если последняя операция в стеке имеет больший приоритет, чем у текущей операции, то помещаем в постфиксное представление (с удалением из стека) все операции, пока выполняется это условие.
   5. Если стек пустой, то заполняем его текущей операцией, иначе, если стек содержит что-либо и если приоритет текущей операции больше, чем приоритет последней операции в стеке, то добавляем в конец стека текущую операцию.
2. Оставшиеся в стеке операции помещаются в постфиксную форму. Алгоритм прекращает свою работу.

#### 3. Вычисление выражения по постфиксной форме:

На вход поступает набор строк, который содержит каждый элемент постфиксной записи арифметического выражения отдельно.

1. Если текущий элемент – лексема, то помещаем её в вершину стека.
2. Если текущий элемент – операция, то извлекаем из стека столько чисел, сколько арность у текущей операции, и используем их в качестве операндов для данной операции.
3. После прохода по всему постфиксному представлению, в стеке остаётся одно число, которое является результатом вычисления. Алгоритм прекращает свою работу.

### Алгоритмы работы с двоичным деревом:

#### 1. [Вставка в дерево.][avltreeinsert]

#### 2. [Удаление из дерева.][avltreedelete]

#### 3. [Поиск по дереву.][avltreesearching]

## Используемые инструменты

  - Система контроля версий [Git][git].
  - Фреймворк для написания автоматических тестов [Google Test][gtest].
  - Среда разработки Microsoft Visual Studio 2019.

